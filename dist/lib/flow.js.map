{"version":3,"sources":["../../src/lib/flow.js"],"names":["flowCommandPath","projectDir","tmpDirPath","tmpFilePath","process","env","VERBOSE","temp","path","suffix","dir","cwd","maxBuffer","Infinity","dontReject","res","err","code","console","error","stderr","stdout","statusData","log","JSON","parse","String","unexpectedException","Error","flowVersion","checkFlowStatus","opts","filename","flowCommandTimeout","strictCoverage","emptyCoverageData","annotation","isFlow","expressions","covered_count","uncovered_count","uncovered_locs","escapeFileName","timeout","percent","NaN","isError","flowCoverageError","undefined","flowCoverageException","message","flowCoverageStderr","flowCoverageParsingError","parsedData","isFlowAnnotation","Boolean","collectFlowCoverageForFile","roundNumber","getCoveredPercent","summarizeAnnotations","collectFlowCoverage","Array","prototype","find","require","shim","fileName","replace","n","numDecimals","fact","Math","pow","floor","round","total","strict","validFlowAnnotation","Set","delete","has","coverageSummaryData","flowFiles","flowWeakFiles","noFlowFiles","filenames","Object","keys","files","forEach","passed","totalFiles","length","globIncludePatterns","globExcludePatterns","threshold","percentDecimals","concurrentFiles","excludeNonFlow","then","waitForCollectedDataFromFiles","Promise","all","drainQueue","now","Date","coverageGeneratedAt","toDateString","toTimeString","annotationSummary","generatedAt","flowStatus","flowAnnotations","cleanupUncoveredLoc","loc","start","source","end","collectCoverageAndGenerateReportForGlob","globIncludePattern","root","pattern","push","data","map"],"mappings":"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","file":"flow.js","sourcesContent":["'use strict';\n\n// @flow\n\nimport minimatch from 'minimatch';\nimport temp from 'temp';\nimport {genCheckFlowStatus} from 'flow-annotation-check';\nimport {exec, glob, writeFile} from './promisified';\n\nimport type {FlowCoverageReportOptions} from './index';\n\n// Load the Array.prototype.find polyfill if needed (e.g. nodejs 0.12).\n/* istanbul ignore if  */\nif (!Array.prototype.find) {\n  require('array.prototype.find').shim();\n}\n\n// Escape special characters in file names.\nexport function escapeFileName(fileName: string): string {\n  return fileName.replace(/([\"\\s'$`\\\\])/g, '\\\\$1');\n}\n\nexport function roundNumber(n: number, numDecimals: number = 0): number {\n  if (numDecimals > 0) {\n    const fact = Math.pow(10, Math.floor(numDecimals));\n    return Math.round(n * fact) / fact;\n  }\n  return Math.floor(n);\n}\n\n/* eslint-disable camelcase */\nexport function getCoveredPercent(\n  {\n    covered_count, uncovered_count\n  }: {\n    covered_count: number, uncovered_count: number\n  },\n  numDecimals: number = 0\n) {\n  const total = covered_count + uncovered_count;\n\n  if (total === 0) {\n    return 100;\n  }\n\n  return roundNumber(covered_count / total * 100, numDecimals);\n}\n/* eslint-disable-line camelcase */\n\nexport function isFlowAnnotation(\n  annotation: string, strict: boolean = false\n): boolean {\n  const validFlowAnnotation = new Set([\n    'flow', 'flow weak', 'flow strict', 'flow strict-local'\n  ]);\n\n  if (strict) {\n    validFlowAnnotation.delete('flow weak');\n  }\n\n  return validFlowAnnotation.has(annotation);\n}\n\n// Definitions and flow types related to checkFlowStatus.\n\nexport type FlowTypeErrorPosition = {\n  offset: number,\n  column: number,\n  line: number\n}\n\nexport type FlowTypeErrorMessage = {\n  type: string,\n  start: number,\n  end: number,\n  line: number,\n  endline: number,\n  path: string,\n  descr: string,\n  context?: string,\n  loc?: {\n    start: FlowTypeErrorPosition,\n    end: FlowTypeErrorPosition,\n    type: string,\n    source: string\n  }\n}\n\nexport type FlowTypeError = {\n  kind: string,\n  level: string,\n  message: Array<FlowTypeErrorMessage>\n}\n\nexport type FlowStatus = {\n  passed: boolean,\n  flowVersion: string,\n  errors: Array<FlowTypeError>\n}\n\nexport async function checkFlowStatus(\n  flowCommandPath: string,\n  projectDir: string,\n  tmpDirPath: ?string\n): Promise<FlowStatus> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path(tmpDirPath ?\n      {suffix: '.json', dir: tmpDirPath} : {suffix: '.json'});\n  }\n\n  const res = await exec(`${flowCommandPath} status --json`,\n                         {cwd: projectDir, maxBuffer: Infinity},\n                         {dontReject: true});\n\n  if (res.err && res.err.code !== 2) {\n    if (process.env.VERBOSE) {\n      console.error('Flow status error', res.err, res.stderr, res.stdout);\n    }\n\n    throw res.err;\n  }\n\n  let statusData: ?FlowStatus;\n\n  if (tmpFilePath) {\n    await writeFile(tmpFilePath, res.stdout || '');\n    console.log('Flow status result saved to', tmpFilePath);\n  }\n\n  try {\n    statusData = JSON.parse(String(res.stdout));\n  } catch (err) {\n    const unexpectedException: ?SyntaxError = err;\n\n    // Verify the integrity of the format of the JSON status result.\n    if (unexpectedException) {\n      throw new Error(`Parsing error on Flow status JSON result: ${err}`);\n    }\n  }\n\n  if (statusData && statusData.flowVersion) {\n    return statusData;\n  }\n\n  throw new Error('Invalid Flow status JSON format');\n}\n\n// Definitions and flow types related to collectFlowCoverageForFile.\n\nexport type FlowUncoveredPos = {\n  line: number,\n  column: number,\n  offset: number,\n  source: string\n}\n\nexport type FlowUncoveredLoc = {\n  start: FlowUncoveredPos,\n  end: FlowUncoveredPos\n}\n\nexport type FlowCoverageJSONData = {\n  expressions: {\n    covered_count: number,\n    uncovered_count: number,\n    uncovered_locs: Array<FlowUncoveredLoc>\n  },\n  filename?: string,\n  // eslint-disable-next-line flowtype/space-after-type-colon\n  annotation?:\n    | 'no flow'\n    | 'flow weak'\n    | 'flow'\n    | 'flow strict'\n    | 'flow strict-local',\n  percent: number,\n  error?: string,\n  isError?: boolean,\n  isFlow: boolean,\n  flowCoverageError?: ?string,\n  flowCoverageException?: ?string,\n  flowCoverageParsingError?: ?string,\n  flowCoverageStderr?: string|Buffer\n}\n\ntype CollectFlowCoverageForFileOptions = {\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  strictCoverage: bool,\n};\n\nexport async function collectFlowCoverageForFile(\n  opts: CollectFlowCoverageForFileOptions,\n  filename: string,\n  tmpDirPath: ?string,\n): Promise<FlowCoverageJSONData> {\n  const {\n    flowCommandPath,\n    flowCommandTimeout,\n    projectDir,\n    strictCoverage\n  } = opts;\n\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path(tmpDirPath ?\n      {suffix: '.json', dir: tmpDirPath} : {suffix: '.json'});\n  }\n\n  const emptyCoverageData = {\n    filename,\n    annotation: 'no flow',\n    isFlow: false,\n    expressions: {\n      covered_count: 0,\n      uncovered_count: 0,\n      uncovered_locs: []\n    }\n  };\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} (timeouts in ${flowCommandTimeout})...`);\n  }\n\n  const res = await exec(\n    `${flowCommandPath} coverage --json ${escapeFileName(filename)}`,\n    // NOTE: set a default timeouts and maxButter to Infinity to prevent,\n    // misconfigured projects and source files that should raises errors\n    // or hangs the flow daemon to prevent the coverage reporter to complete\n    // the data collection. (See https://github.com/rpl/flow-coverage-report/pull/4\n    // and https://github.com/rpl/flow-coverage-report/pull/5 for rationale,\n    // thanks to to @mynameiswhm and @ryan953  for their help on hunting down this issue)\n    {cwd: projectDir, timeout: flowCommandTimeout, maxBuffer: Infinity},\n    {dontReject: true});\n\n  if (res.err) {\n    console.error('ERROR Collecting coverage data from', filename, res.err, res.stderr);\n\n    if (process.env.VERBOSE) {\n      if (tmpFilePath) {\n        await writeFile(tmpFilePath, res.stdout || '');\n      }\n    }\n\n    // TODO: collect errors and put them in a visible place in the\n    // generated report.\n    return {\n      ...emptyCoverageData,\n      percent: NaN,\n      isError: true,\n      flowCoverageError: undefined,\n      flowCoverageException: res.err && res.err.message,\n      flowCoverageStderr: res.stderr,\n      flowCoverageParsingError: undefined\n    };\n  }\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} completed.`);\n    if (tmpFilePath) {\n      await writeFile(tmpFilePath, res.stdout || '');\n      console.log(`Saved json dump of collected coverage data from ${filename} to ${tmpFilePath}.`);\n    }\n  }\n\n  let parsedData: ?FlowCoverageJSONData;\n  let flowCoverageParsingError: string;\n\n  if (res.stdout) {\n    try {\n      parsedData = JSON.parse(String(res.stdout));\n    } catch (err) {\n      flowCoverageParsingError = err.message;\n    }\n  }\n\n  if (res.stderr) {\n    try {\n      parsedData = JSON.parse(String(res.stderr));\n      delete res.stderr;\n    } catch (err) {\n    }\n  }\n\n  if (parsedData && !parsedData.error) {\n    parsedData.filename = filename;\n    parsedData.annotation = await genCheckFlowStatus(flowCommandPath, filename);\n    parsedData.isFlow = isFlowAnnotation(parsedData.annotation, Boolean(strictCoverage));\n\n    // In strictCoverage mode all files that are not strictly flow\n    // (e.g. non annotated and flow weak files) are considered\n    // as completely uncovered.\n    if (strictCoverage && !parsedData.isFlow) {\n      parsedData.expressions.uncovered_count += parsedData.expressions.covered_count;\n      parsedData.expressions.covered_count = 0;\n    }\n    return parsedData;\n  }\n\n  return {\n    ...emptyCoverageData,\n    percent: NaN,\n    isError: true,\n    isFlow: Boolean(parsedData && parsedData.isFlow),\n    flowCoverageError: parsedData && parsedData.error,\n    flowCoverageException: undefined,\n    flowCoverageParsingError,\n    flowCoverageStderr: res.stderr\n  };\n}\n\n// Definition and flow types related to collectForCoverage.\n\ntype FlowAnnotationSummary = {\n  passed: boolean,\n  flowFiles: number,\n  flowWeakFiles: number,\n  noFlowFiles: number,\n  totalFiles: number,\n};\n\nexport type FlowCoverageSummaryData = {\n  covered_count: number,\n  uncovered_count: number,\n  percent: number,\n  threshold: number,\n  strictCoverage: boolean,\n  generatedAt: string,\n  flowStatus: FlowStatus,\n  flowAnnotations: FlowAnnotationSummary,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  concurrentFiles: number,\n  files: {\n    [key: string]: FlowCoverageJSONData\n  }\n}\n\nexport function summarizeAnnotations(\n  coverageSummaryData: FlowCoverageSummaryData\n): FlowAnnotationSummary {\n  let flowFiles = 0;\n  let flowWeakFiles = 0;\n  let noFlowFiles = 0;\n\n  const filenames = Object.keys(coverageSummaryData.files);\n\n  filenames.forEach(filename => {\n    const {annotation} = coverageSummaryData.files[filename];\n    switch (annotation) {\n      case 'flow weak':\n        flowWeakFiles += 1;\n        break;\n      case 'no flow':\n        noFlowFiles += 1;\n        break;\n      default:\n        if (typeof annotation === 'string' &&\n            isFlowAnnotation(annotation, true)) {\n          flowFiles += 1;\n          return;\n        }\n        throw new Error(`Unexpected missing flow annotation on ${filename}`);\n    }\n  });\n\n  return {\n    passed: (flowWeakFiles + noFlowFiles) === 0,\n    flowFiles,\n    flowWeakFiles,\n    noFlowFiles,\n    totalFiles: filenames.length\n  };\n}\n\nexport function collectFlowCoverage(\n  opts: FlowCoverageReportOptions,\n  tmpDirPath: ?string,\n): Promise<FlowCoverageSummaryData> {\n  const {\n    flowCommandPath,\n    projectDir,\n    globIncludePatterns,\n    globExcludePatterns = [],\n    threshold,\n    percentDecimals,\n    concurrentFiles = 1,\n    strictCoverage,\n    excludeNonFlow\n  } = opts;\n\n  return checkFlowStatus(flowCommandPath, projectDir, tmpDirPath).then(flowStatus => {\n    const now = new Date();\n    const coverageGeneratedAt = now.toDateString() + ' ' + now.toTimeString();\n\n    const annotationSummary = {\n      passed: false,\n      flowFiles: 0,\n      flowWeakFiles: 0,\n      noFlowFiles: 0,\n      totalFiles: 0\n    };\n\n    const coverageSummaryData: FlowCoverageSummaryData = {\n      threshold,\n      covered_count: 0, uncovered_count: 0, // eslint-disable-line camelcase\n      percent: 0,\n      generatedAt: coverageGeneratedAt,\n      flowStatus,\n      flowAnnotations: annotationSummary,\n      files: {},\n      globIncludePatterns,\n      globExcludePatterns,\n      concurrentFiles,\n      strictCoverage: Boolean(strictCoverage),\n      excludeNonFlow\n    };\n\n    // Remove the source attribute from all ucovered_locs entry.\n    function cleanupUncoveredLoc(loc) {\n      delete loc.start.source;\n      delete loc.end.source;\n      return loc;\n    }\n\n    let waitForCollectedDataFromFiles = [];\n\n    async function drainQueue() {\n      if (process.env.VERBOSE) {\n        console.log(`Wait for ${waitForCollectedDataFromFiles.length} queued files.`);\n      }\n      // Wait the queued files.\n      await Promise.all(waitForCollectedDataFromFiles);\n      // Empty the collected Data From files queue.\n      waitForCollectedDataFromFiles = [];\n    }\n\n    function collectCoverageAndGenerateReportForGlob(globIncludePattern) {\n      return glob(globIncludePattern, {cwd: projectDir, root: projectDir})\n        .then(async files => {\n          for (const filename of files) {\n            // Skip files that match any of the exclude patterns.\n            if (globExcludePatterns && globExcludePatterns.find(pattern => minimatch(filename, pattern)) !== undefined) {\n              if (process.env.VERBOSE) {\n                console.log(`Skip ${filename}, matched excluded pattern.`);\n              }\n              continue;\n            }\n\n            if (excludeNonFlow) {\n              // eslint-disable-next-line no-await-in-loop\n              const annotation = await genCheckFlowStatus(flowCommandPath, filename);\n              if (annotation === 'no flow') {\n                if (process.env.VERBOSE) {\n                  console.log(`Skip ${filename}, matched 'no flow' in excludeNonFlow mode.`);\n                }\n                continue;\n              }\n            }\n\n            if (process.env.VERBOSE) {\n              console.log(`Queue ${filename} flow coverage data collection`);\n            }\n\n            waitForCollectedDataFromFiles.push(collectFlowCoverageForFile(opts, filename, tmpDirPath).then(data => {\n              /* eslint-disable camelcase */\n              coverageSummaryData.covered_count += data.expressions.covered_count;\n              coverageSummaryData.uncovered_count += data.expressions.uncovered_count;\n              data.percent = getCoveredPercent(data.expressions, percentDecimals);\n\n              if (!data.filename) {\n                throw new Error('Unxepected missing filename from collected coverage data');\n              }\n\n              coverageSummaryData.files[data.filename] = data;\n\n              data.expressions.uncovered_locs =\n                data.expressions.uncovered_locs.map(cleanupUncoveredLoc);\n              /* eslint-enable camelcase */\n            }));\n\n            // If we have collected at least `concurrentFiles` number of files,\n            // wait the queue to be drained.\n            if (waitForCollectedDataFromFiles.length >= concurrentFiles) {\n              await drainQueue(); // eslint-disable-line no-await-in-loop\n            }\n          }\n\n          // Wait for any remaining queued file.\n          if (waitForCollectedDataFromFiles.length > 0) {\n            await drainQueue();\n          }\n\n          return files;\n        });\n    }\n\n    return Promise\n      .all(globIncludePatterns.map(collectCoverageAndGenerateReportForGlob))\n      .then(() => {\n        coverageSummaryData.percent = getCoveredPercent(coverageSummaryData, percentDecimals);\n        coverageSummaryData.flowAnnotations = summarizeAnnotations(\n          coverageSummaryData\n        );\n\n        return coverageSummaryData;\n      });\n  });\n}\n"]}